#!/usr/bin/env python
#
# freshmeat-submit -- script transactions with the Freshmeat server

import sys

def error(m):
    sys.stderr.write("freshmeat-submit: %s\n" % m)
    sys.stderr.flush()
    sys.exit(1)

if sys.version[:6] < '2.2.0':
    error("You must upgrade to Python 2.2.0 or better to use this code.")

import urllib2, json, netrc, email.Parser, optparse, commands

class FreshmeatSessionException:
    def __init__(self, msg):
        self.msg = msg

class Update:
    "Encapsulate dictionaries describing a project metadata update."
    def __init__(self):
        self.name = None
        self.per_project = {}
        self.urlassoc = []
        self.per_release = {}
    def __repr__(self):
        return "Project: " + self.name + "\n" + \
                  "Project Data: " + `self.per_project` + "\n" + \
                  "URLs: " + `self.urlassoc` + "\n" + \
                  "Release Data: " + `self.per_release` + "\n"

class FreshmeatSession:
    "Encapsulate the state of a Freshmeat API session."

    def __init__(self, auth=None, verbose=0, emit_enable=True):
        "Initialize Freshmeat session credentials."
        self.auth = auth
        self.verbose = verbose
        self.emit_enable = emit_enable
        self.project = None
        # If user didn't supply credentials, fetch from ~/.netrc
        if not self.auth:
            try:
                credentials = netrc.netrc()
            except netrc.NetrcParseError, e:
                raise FreshmeatSessionException("ill-formed .netrc: %s:%s %s" \
                                               % (e.filename, e.lineno, e.msg))
            except IOError, e:
                raise FreshmeatSessionException(("missing .netrc file %s" % \
                                                 str(e).split()[-1]))
            ret = credentials.authenticators("freshmeat")
            if not ret:
                raise FreshmeatSessionException("no credentials for Freshmeat")
            login, self.auth, password = ret

    def on_project(self, name):
        "Select project by Freshmeat shortname."
        if self.verbose:
            print "Selecting project: %s" % name
        self.project = name
        query = "http://freshmeat.net/projects/%s.json?auth_code=%s" \
                % (self.project, self.auth)
        handle = urllib2.urlopen(query)
        content = json.loads(handle.read())
        content = content['project']
        self.permalink = content['permalink'] 

    def edit_request(self, url, request):
        "Wrap a JSON object with the auth code and ship it as a POST request"
        url = "http://freshmeat.net/" + url
        data = {"auth_code" : self.auth}
        data.update(request)
        data = json.dumps(data)
        headers = {"Content-Type" : "application/json"}
        if self.verbose:
            print "Request URL:", url
        #if self.verbose:
        #    print "Request headers:", headers
        if self.verbose:
            print "Request data:", data
        if self.emit_enable:
            handle = urllib2.urlopen(urllib2.Request(url=url, data=data, headers=headers))
            if self.verbose:
                print handle.info()
                content = handle.read()
                if self.verbose:
                    print "Response:", content

    def publish_release(self, data):
        "Add a new release to the current project."
        if self.verbose:
            print "Publishing %s release: %s" % (self.project, `data`)
        self.edit_request("projects/" + self.permalink + "/releases.json",
                          {"release": data})

    def withdraw_release(self, release):
        "Withdraw a specified release from the current project."
        if self.verbose:
            print "Withdrawing %s release: %s" % (self.project, release)
        raise FreshmeatSessionException("Release removal is not yet implemented in the 3.0 API.")

    def update_core(self, coredata):
        "Update the core data for a project."
        if self.verbose:
            print "Core data update for %s is: %s" % (self.project, coredata)
        self.edit_request("projects/" + self.permalink + ".json",
                          {"project": data})

    def update_urls(self, urlassoc):
        "Update URL list for a project."
        if self.verbose:
            print "URL list update for %s is: %s" % (self.project, urlassoc)
        # First, get permalinks for all existing URLs
        query = "http://freshmeat.net/projects/%s/urls.json?auth_code=%s" \
                % (self.permalink, self.auth)
        handle = urllib2.urlopen(query)
        content = json.loads(handle.read())
        if self.verbose:
            print "Returned URL list:", content
        permadict = {}
        for item in content:
            inner = item['url']
            permadict[inner['label']] = inner['permalink']
        # OK, now run through the update list...
        for (label, url) in urlassoc:
            if label in permadict:
                # updating where we need to
                self.edit_request("projects/%s/urls/%s.json"
                                  % (self.permalink, permadict[label]),
                                  {"url" : {"label": label, "location" : url}})
            else:
                # and adding where we don't.
                self.edit_request("projects/%s/urls.json"
                                  % (self.permalink,),
                                  {"url" : {"label": label, "location" : url}})

focus_values = (
    "Initial freshmeat announcement",
    "Documentation",
    "Code cleanup",
    "Minor feature enhancements",
    "Major feature enhancements",
    "Minor bugfixes",
    "Major bugfixes",
    "Minor security fixes",
    "Major security fixes",
)

# Note: Release Focus is no longer a real Freshmeat field; we'll remap it later.
freshmeat_field_map = (
    ("Project",          "P", "name"),                   # Project
    ("Summary",          "S", "oneliner"),               # Project
    ("Description",      "D", "description"),            # Project
    ("License-List",     "L", "license_list"),           # Project
    ("Project-Tag-List", "T", "project_tag_list"),       # Project
    ("Version",          "v", "version"),                # Release
    ("Changes",          "c", "changelog"),              # Release
    ("Hide",             "x", "hidden_from_frontpage"),  # Release
    ("Release-Focus",    "r", "release_focus"),          # Release
    ("Release-Tag-List", "t", "tag_list"),               # Release
    )

# Which attributes have project scope, all others have release scupe
freshmeat_projectwide = ('name',
                         'description',
                         'oneliner',
                         'license_list',
                         'project_tag_list')

def get_rpm_field(fld, rpm):
    cmd = "rpm --queryformat='%%{%s}' -qp %s" % (fld, rpm)
    (status, output) = commands.getstatusoutput(cmd)
    if status != 0:
        raise ValueError
    return output

def crack_rpm(rpm, meta, urls):
    "Extract freshmeat metadata from an RPM."
    try:
        # Some fields can be copied literally if present.
        if not "name" in meta:
            meta["name"] = get_rpm_field("name", rpm)
        if not "description" in meta:
            meta["description"] = get_rpm_field("description", rpm)
        if not "version" in meta:
            meta["version"] = get_rpm_field("version", rpm)
        # This doesn't work.  The values don't map over.
        #if not "license" in meta:
        #    meta["license"] = get_rpm_field("license", rpm)
        if not "url_homepage" in meta:
            meta["url_homepage"] = get_rpm_field("url", rpm)
        if not "changelog" in meta:
            # Querying gets you the first entry, apparently
            # blank-line-delimited.
            changes = get_rpm_field("changelogtext", rpm)
            # Canonicalize, stripping leading spaces.
            changes = map(lambda x: x.strip(), changes.split('\n'))
            changes = "\n".join(changes) + "\n"
            meta["changelog"] = changes 
        # RPMs have a source field; figure out which Freshmeat field it maps to
        source = get_rpm_field("source", rpm)
        if source.endswith(".tar.gz") or source.endswith(".tgz"):
            if "Tar/GZ" not in urls:
                urls["Tar/GZ"] = source
        if source.endswith(".tar.bz2"):
            if "Tar/BZ" not in urls:
                urls["Tar/BZ"] = source
    except ValueError:
        pass

class FreshmeatMetadataFactory:
    "Factory class for producing Metadata records"

    def __init__(self):
        self.message_parser = email.Parser.Parser()
        self.argument_parser = optparse.OptionParser( \
            usage="usage: %prog [options]")
        for (msg_field, shortopt, rpc_field) in freshmeat_field_map:
            self.argument_parser.add_option("-" + shortopt,
                                            "--" + msg_field.lower(),
                                            dest=rpc_field,
                                            help="Set the %s field"%msg_field)
        self.argument_parser.add_option('-d', '--delete', dest='delete',
                          default=False, action='store_true',
                          help='Suppress reading fields from stdin.')
        self.argument_parser.add_option('-n', '--no-stdin', dest='read',
                          default=True, action='store_false',
                          help='Suppress reading fields from stdin.')
        self.argument_parser.add_option('-N', '--dryrun', dest='dryrun',
                          default=False, action='store_true',
                          help='Suppress reading fields from stdin.')
        self.argument_parser.add_option('-V', '--verbose', dest='verbose',
                          default=False, action='store_true',
                          help='Enable verbose debugging.')
        
    def header_to_field(self, hdr):
        lhdr = hdr.lower().replace("-", "_")
        for (alias, shortopt, field) in freshmeat_field_map:
            if lhdr == alias.lower().replace("-", "_"):
                return field
        raise FreshmeatSessionException("Illegal field name %s" % hdr)

    def getMetadata(self, stream):
        "Return an Update object describing project and release attributes."
        data = {}
        urls = {}
        (options, args) = self.argument_parser.parse_args()
        # First stuff from RPMs if present.
        for file in args:
            if file.endswith(".rpm"):
                crack_rpm(file, data, urls)
        # Second, stuff from stdin if present
        prior_version = data.get("version")
        if options.read:
            message = self.message_parser.parse(stream)
            for (key, value) in message.items():
                if key.endswith("-URL"):
                    urls.update({key[:-4] : value})
                else:
                    if key.endswith("List"):
                        value = map(lambda x: x.strip(), value.split())
                    data.update({self.header_to_field(key) : value})
            if not 'changelog' in data:
                data['changelog'] = message.get_payload()
            if prior_version and data.get("version") != prior_version:
                raise FreshmeatSessionException("Version conflict on stdin.")
        # Merge in options from the command line;
        # they override what's on stdin.
        controls = ('read', 'delete', 'no-stdin', 'dryrun', 'verbose')
        prior_version = data.get("version")
        for (key, value) in options.__dict__.items():
            if key not in controls and value != None:
                data[key] = value
                del options.__dict__[key]
        if data.get("version") != prior_version:
            raise FreshmeatSessionException("Version conflict in options.")
        # Hidden flag special handling
        if "hidden_from_frontpage" in data:
            data["hidden_from_frontpage"] = data["hidden_from_frontpage"] in ("Y", "y") 
        # Release-Focus field special handling.
        if "release_focus" in data:
            if data["release_focus"] in '123456789':
                data["release_focus"] = focus_values[int(data["release_focus"])-1]
            if data["release_focus"] not in focus_values:
                raise FreshmeatSessionException("Invalid release focus")
            if "tag_list" not in data:
                data["tag_list"] = data["release_focus" ]
            else:
                data["tag_list"].append(data["release_focus" ])
            del data["release_focus"]
        # Now merge in the URLs, doing symbol substitution
        urllist = []
        for (label, furl) in urls.items():
            for (k, v) in data.items():
                if type(v) == type(""):
                    furl = furl.replace('${' + k + '}', v)
            urllist.append((label, furl))
        # Sort out what things go where 
        update = Update()
        update.name = data.pop('name')
        update.urlassoc = urllist
        for (k, v) in data.items():
            if k in freshmeat_projectwide:
                # Hack to get around a namespace collision
                if k == "project_release_tag":
                    k = "release_tag"
                update.per_project[k] = v
            else:
                update.per_release[k] = v
        # Return this
        return (options, update)

if __name__ == "__main__":
    try:
        # First, gather update data from stdin and command-line switches
        factory = FreshmeatMetadataFactory()
        (options, update) = factory.getMetadata(sys.stdin)
        # Some switches shouldn't be passed to the server
        verbose = 'verbose' in options.__dict__ and options.verbose
        delete  = 'delete' in options.__dict__ and options.delete
        dryrun  = 'dryrun' in options.__dict__ and options.dryrun
        # Time to ship the update.
        # Establish session
        session = FreshmeatSession(verbose=int(verbose), emit_enable=not dryrun)
        session.on_project(update.name)
        # OK, now actually add or delete the release.
        if update.per_release:
            if delete:
                session.withdraw_release(update['version'])
            else:
                session.publish_release(update.per_release)
        if update.per_project:
            session.update_core(update.per_project)
        if update.urlassoc:
            session.update_urls(update.urlassoc)
    except FreshmeatSessionException, e:
        print >>sys.stderr,"freshmeat-submit:", e.msg
        sys.exit(1)
    except urllib2.HTTPError, f:
        print >>sys.stderr,"freshmeat-submit: HTTPError %s" %  (f.code)
        print >>sys.stderr,f.read()
        sys.exit(1)
    except urllib2.URLError, f:
        print >>sys.stderr,"freshmeat-submit: URLError %s" %  (f.reason,)
        print >>sys.stderr,f.read()
        sys.exit(1)

# end

